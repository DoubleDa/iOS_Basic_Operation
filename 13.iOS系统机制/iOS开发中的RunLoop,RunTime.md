# iOS开发中的RunLoop,RunTime

- OC调用函数机制
	- 函数调用称之为消息的分发，编译的时候不需要查找要执行的函数，必须要等到真正运行的时候，程序才查找要执行的函数。
	- 对于C语言，函数调用是由编译器直接转化完成的，在编译时程序就开始查找要执行的函数(C语言函数调用原理)。

 > 在C语言中，仅申明一个函数，不去实现。其他地方调用此函数。编译时就会报错(C语言编译时查找要执行的函数，找不到所以报错)。而同样的情况在OC中并不会报错，只有在运行时候才会报错。(OC运行时才查找要执行的函数)

- OC函数调用的底层实现(让程序拥有运行时特性)
	- Objective-C之所以能做到运行时才查找要执行的函数主要归功于runTime的SDK。
	- objc_msgSend(id self,SEL op,...),方法实现了函数查找和匹配

1. RunTime:

	- runtime是一套比较底层的纯C语言API, 属于1个C语言库, 包含了很多底层的C语言API。在我们平时编写的OC代码中, 程序运行过程时, 其实最终都是转成了runtime的C语言代码, runtime算是OC的幕后工作者

	- runtime是属于OC的底层, 可以进行一些非常底层的操作(用OC是无法现实的, 不好实现)
		- 在程序运行过程中, 动态创建一个类(比如KVO的底层实现)
		- 在程序运行过程中, 动态地为某个类添加属性\方法, 修改属性值\方法
		- 遍历一个类的所有成员变量(属性)\所有方法 
			- 例如：我们需要对一个类的属性进行归档解档的时候属性特别的多，这时候，我们就会写很多对应的代码，但是如果使用了runtime就可以动态设置！ 

	- 简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。对于C语言，函数的调用在编译的时候会决定调用哪个函数（ C语言的函数调用请看这里 ）。编译完成之后直接顺序执行，无任何二义性。OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。

	- 举例说明：比如你[obj makeText]；则运行时就这样的：首先，编译器将代码[obj makeText];转化为objc_msgSend(obj, @selector (makeText));，在objc_msgSend函数中。首先通过obj的isa指针找到obj对应的class。在Class中先去cache中,通过SEL查找对应函数method（猜测cache中method列表是以SEL为key通过hash表来存储的，这样能提高函数查找速度），若 cache中未找到。再去methodList中查找，若methodlist中未找到，则取superClass中查找。若能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。