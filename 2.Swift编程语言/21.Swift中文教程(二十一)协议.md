# Swift中文教程（二十一） 协议  --没有失败，唯有放弃

**协议定义了一个蓝图，规定了用来实现某一特定工作或者功能所必需的方法和属性。类结构体或枚举类型都可以遵循协议并提供具体实现来完成协议定义的方法和功能。任意能够满足协议要求的类型被称为这个协议**

- 语法:
	- 定义:
		`protocol <protocol_name>{//协议内容}`      
	- 使用:
		`class/struct/enmu: <父类>,<协议>`
- 对属性的规定:

> 协议可以规定其遵循者提供特定名称和类型的实例属性(instance property)或类属性(type property) ,而不指定是存储型属性(stored property)还是计算型属性(calculate property)。此外还必须指明是只读的还是可读可写的。

- 对方法的绑定:

> 协议可以要求其遵循者实现某些指定的实例方法或类方法。这些方法作为协议的一部分,像普通的方法一样放在
协议的定义中,但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法,和普通方法的定义方式相
同。但是在协议的方法定义中,不支持参数默认值。

- 对Mutating方法的规定:(struct,enmu中实现改protocol必须写mutating，class不用)

> 有时需要在方法中改变它的实例。例如,值类型(结构体,枚举)的实例方法中,将 mutating 关键字作为函数的前 缀,写在 func 之前,表示可以在该方法中修改它所属的实例及其实例属性的值

- 对构造器的规定

> 协议可以要求它的遵循者实现指定的构造器。你可以像书写普通的构造器那样,在协议的定义里写下构造器的声
明,但不需要写花括号和构造器的实体.

	- 你可以在遵循该协议的类中实现构造器,并指定其为类的指定构造器或者便利构造器(必修加required)
	- 必要构造器(required),required修饰符可以保证:所有的遵循该协议的子类,同样能为构造器规定提供一个显式的实现或继承实现。
	- 如果类已经被标记为final,那么不需要在协议构造器的实现中使用 required 修饰符
	1. 协议构造器规定在类中的实现
	2. 可失败构造器的规定:可以通过给协议 Protocols 中添加可失败构造器来使遵循该协议的类型必须实现该可失败构造器

	> 如果在协议中定义一个非可失败构造器,则在遵循该协议的类型中必须添加同名同参数的非可失败构造 器或隐式解析类型的可失败构造器( init! )。


- 协议类型：
尽管协议本身并不实现任何功能,但是协议可以被当做类型来使用。
	－ 作为函数、方法或构造器中的参数类型或返回值类型 
	－ 作为常量、变量或属性的类型
	－ 作为数组、字典或其他容器中的元素类型 

> 注意: 协议是一种类型,因此协议类型的名称应与其他类型(Int,Double,String)的写法相同,使用大写字母开头的 驼峰式写法,例如( FullyNamed 和 RandomNumberGenerator )


- 委托(代理)模式 

> 委托是一种设计模式,它允许类或结构体 将一些需要它们负责的功能交由(委托)给其他的类型的实例。委托模式的实现很简单: 定义协议来封装那些需要被委托的函数和方法,使其遵循者拥有这些被委托的函数和方法委托模式可以用来响应特定的动作或接收外部数据源提供的数据,而无需要知道外部数据源的类型信息。

