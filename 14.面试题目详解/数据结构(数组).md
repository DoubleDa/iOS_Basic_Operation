#数据结构(数组,链表)

> 区别：
 1. 链表存储结构的内存地址不一定是连续的，但顺序存储结构的内存地址一定是连续的；
 2. 链式存储适用于在较频繁地插入、删除、更新元素时，而顺序存储结构适用于频繁查询时使用。

> 数据的逻辑结构分为线性结构和非线性结构。
 1. 常用的线性结构有：线性表，栈，队列，双队列，数组，串。
 2. 常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树等)，图。

***

1. 链表优于数组的特点
	- 链表方便删除和插入，只需知道结点和要插入的信息即可
	- 长度可变，一般链表是动态分配内存空间
	- 链表的结点信息至少包含数据域和指针域，相同数据下：数组的大小是链表大小的子集

2. short a[100],sizeof(a) 返回什么: sizeof返回对象或类型所占内存字节数

3. 当在一个有序的顺序存储表上查找一个数据时,即可用折半查找,也可用顺序查找,但前者比后者的查找速度():	在大部分情况下要快
	- 顺序查找简单的从头到尾的查找，对数据没有要求，而折半查找要求查找的数据是按顺序排列的，然后找中间数，若中间数大，则把中间数当成最后一个数找他们的中间数。反之，则把中间数当成第一个数。找他们的中间数。这样，一直找下去，直到找到或者中间数和第一个数或者最后一个数相等。它较顺序查找，效率较高。

4. 广义表中的元素或者是一个不可分割的原子,或者是一个非空的广义表(错误) : 
	- 广义表的元素可以为空～题目中只提到具有原子性和非空性的元素。所以题目表述错误
	- 广义表的元素可以是广义表，也可以是原子，其长度为n（n>=0）

5. 一个5*4的矩阵，有多少个长方形？
	- 长任取两个点C(6,2)*宽任取两个点C(5,2) = 15* 10 = 150

6. 在一个有8个int数据的数组中，随机给出数组的数据，找出最大和第二大元素一定需要进行（）次比较：
	-  答案是 B 比如 A B C D E F G H，通过8进4的方式，A与B比较， C与D比较.....然后再4进2，A与C比较（假设A,C比B,D大），E与G比较。再2进1，比如A与E比较（假设A，E比C,G大）选出最大的A，总共7次。然后次大的数一定是被最大数PK下去的，所以再选B C E三个比较2次得到次大的数

7.  下列说法错误的有（BCD）  
	- 数组是一种对象
	- 数组属于一种原生类
	- int number=[]{31,23,33,43,35,63}
	- 数组的大小可以任意改变
	- Java中的那些基本类型属于原生类，而数组是引用类型，不属于原生类，可以看成是一种对象。而C中的数组声明和初始化的格式不对数组的大小一旦指定，就不可以进行改变。

8. 以下操作中，数组比线性表速度更快的是(ACE)
	- 原地逆序
	- 头部插入
	- 返回中间节点
	- 返回头部节点
	- 选择随机节点
	- 数组是顺序存储的线性表，相对于链表而言主要的优点就是可以通过下标随机访问数组中的任意元素，C选项的访问中间节点，数组可以通过array[length/2]访问，链表需要依次查找到中间节点。
	- 数组是随机存取，线性表是逻辑上连续但物理上分开存放，因此查询、修改操作数组更快，数组表示线性表的好处在于能随机存取 但插入、删除等操作线性表更快

9. 下列关于线性表中的链表描述正确的是？
	- 适用于数据项数量不能预知的情况。
	- 逻辑相邻的2元素的存储空间可以是不连续的。
	- 链表节点一般有数据元素和指针域两部分组成。
	- 存储空间需要动态分配。

10. A[N,N]是对称矩阵,将下面三角(包括对角线)以行序存储到一维数组T[N(N+1)/2]中,则对任一上三角元素a[i][j]对应T[k]的下标k是(j(j+1)/2+i)
	- 由于是对称矩阵，因此aij=aji;存储的时候就只需要存储一半就可以，存n(n+1)/2 个数;当i>j,s[i(i+1)/2+j] = aij 

11. 设有数组A[i,j],数组的每个元素长度为3字节,i的值为1到8,j的值为1到10,数组从内存首地址BA开始顺序存放,当用以列为主存放时,元素A[5,8]的存储首地址为()
	- 本题A[5,8]以列为主，该元素处于第八列，前七列是满的每列8个元素，该元素处于第五行，他的前一个元素A[4,8]的结束地址就是所求的开始，最后，每个元素占3。所以有公式：(7*8+4)*3		ps: 一个 8*10 的数组

12. 当很频繁地对序列中部进行插入和删除操作时，应该选择使用的容器是: list
	- vector表示一段连续的内存区域，随机访问效率很高，因为每次访问离起始处的位移都是固定的，但是在随意位置插入删除元素效率很低，因为它需要将后面的元素复制一遍。 list表示非连续的内存区域，并通过一对指向首尾元素的指针双向链接起来，从而允许向前和向后两个方向进行遍历。在list的任意位置插入和删除元素的效率都很高：指针必须被重新赋值，但不需要用拷贝元素来实现移动。他对随机访问支持不好，需要遍历中间的元素。每个元素有两个指针的额外空间开销。 deque（双端队列，发音为'deck'）也表示一段连续的内存区域，但是他支持高效的在其首部插入和删除元素。 选择顺序容器类型的一些准则： 如果我们需要随机访问一个容器，则vector要比List好得多。 如果我们一直要存储元素的个数，则vector又是一个比list好的选择。 如果我们需要的不只是在容器两端插入和删除元素，则list显然比vector好。 除非我们需要在容其首部插入和删除元素，否则vector要比deque好。
	- C++ STL 的实现：
		1.vector  底层数据结构为数组 ，支持快速随机访问
		2.list    底层数据结构为双向链表，支持快速增删
		3.deque   底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问
		4.stack   底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
		5.queue   底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
		6.45是适配器,而不叫容器，因为是对容器的再封装
		7.priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现
		8.set       底层数据结构为红黑树，有序，不重复
		9.multiset  底层数据结构为红黑树，有序，可重复 
		10.map      ﻿﻿﻿﻿底层数据结构为红黑树，有序，不重复
		11.multimap 底层数据结构为红黑树，有序，可重复
		12.hash_set ﻿﻿﻿﻿底层数据结构为hash表，无序，不重复
		13.hash_multiset 底层数据结构为hash表，无序，可重复 
		14.hash_map      ﻿﻿﻿﻿底层数据结构为hash表，无序，不重复
		15.hash_multimap 底层数据结构为hash表，无序，可重复 

13. 在java 中，声明一个数组时，不能直接限定数组长度，只有在创建实例化对象时，才能对给定数组长度.。
	- String a[]=new String[50];
	- String b[];
	- char c[];
	- String d[50];(错误)
	- char e[50];(错误)

14. 最坏情况下，合并两个大小为n的已排序数组所需要的比较次数为: 2n-1; 最好情况下，合并两个大小为n的已排序数组所需要的比较次数为:1

15. 给定一个m行n列的整数矩阵（如图），每行从左到右和每列从上到下都是有序的。判断一个整数k是否在矩阵中出现的最优算法，在最坏情况下的时间复杂度是: O(m+n)。
	- 从矩阵的右上角开始，若右上角元素大于所找，则可右上角元素所在的列的所有元素均大于所找元素，下次查找忽略该列；若右上角元素小于所找，则右上角元素所在行的所有元素均小于所找元素，下次查找，忽略该行；若相等，结束查找；否则，由新形成的矩阵利用上述方式继续查找。是不是B，O(m+n).

16. 有一个100*90的稀疏矩阵,非0元素有10个,设每个整型数占2字节,则用三元组表示该矩阵时,所需的字节数是()
	- 每个元素要用行号,列号,元素值来表示,在用三元组表示稀疏矩阵,还要三个成员来记住,矩阵的行数列数,总的元素数,所以所需的字节数是10*（1+1+1）*2+3*2=66

17. 数组指针和指针数组有什么区别 ？
	- 数组指针只是一个指针变量，它占有内存中一个指针的存储空间 (int (*p)[n])
	- 指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间 (int *p[n])