# P问题、NP问题和NPC问题详解:

> 时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快,一个O(0.01*n^3)的程序的效率比O(100*n^2)的效率低，尽管在n很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终O(n^3)的复杂度将远远超过O(n^2)。我们也说，O(n^100)的复杂度小于O(1.01^n)的复杂度
 - O(1): 不管数据有多大，程序处理花的时间始终是那么多的(常数级复杂度) 
 - O(n): 数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是O(n);
 - O(n^2): 冒泡排序、插入排序
 - O(a^n):
 - O(n!):
 
- P类问题: 验证一个解只需要O(n)的时间复杂度，也就是说我可以花O(n)的时间把我猜的路径的长度加出来。那么，只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题
	 - Hamilton回路

- NP类问题: NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。NP问题不是非P类问题

> 在问题中，找一个解很困难，但验证一个解很容易。验证一个解只需要O(n)的时间复杂度，也就是说我可以花O(n)的时间把我猜的路径的长度加出来。那么，只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP问题。当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。所有的P类问题都是NP问题

- NPC:不能找到复杂度为多项式级的算法首先。它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它。

>  归约(约化):
  - 一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。
  - 规约具有传递性
  
	- The Halting Problem就是一个著名的不可解问题
	- 逻辑电路问题,给定一个逻辑电路，问是否存在一种输入使输出为True

- NP-Hard问题:它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比NPC问题的范围广）。

